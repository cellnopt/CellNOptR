makeCNOlist<-function(dataset,subfield){

#check that all the needed elements are present
	if(!is.list(dataset)){
		stop("The input to this function should be a list with elements 'dataMatrix', 'TRcol','DAcol',and 'DVcol'")
		}
		
	if(length(dataset) != 4){
		stop("The input to this function should be a list with elements 'dataMatrix', 'TRcol','DAcol',and 'DVcol'")
		}
		
	if(sum(c("dataMatrix","TRcol","DAcol","DVcol") %in% names(dataset))!=4){
		stop("The input to this function should be a list with elements 'dataMatrix', 'TRcol','DAcol',and 'DVcol'")
		}
#first, we summarise the replicates in the dataMatrix: replicates are rows in the dataset$dataMatrix
#that have the exact same values in all TR: and DA: columns
	duplCond<-as.matrix(dataset$dataMatrix[,c(dataset$TRcol,dataset$DAcol)])
	duplRows<-which(duplicated(duplCond) == TRUE)
	
	while(length(duplRows) != 0){
		dupIndex<-apply(duplCond,MARGIN=1,function(x) all(x == duplCond[duplRows[1],]))
		dupIndex<-which(dupIndex == TRUE)
		dupMatrix<-dataset$dataMatrix[dupIndex,]
		
		#compute the new row as the average across duplicate rows
		newRow<-colMeans(dupMatrix)
		
		#replace the first duplicated row by the summarised one
		dataset$dataMatrix[dupIndex[1],]<-newRow
		
		#remove the other summarised rows
		dataset$dataMatrix<-dataset$dataMatrix[-dupIndex[2:length(dupIndex)],]
		
		duplCond<-as.matrix(dataset$dataMatrix[,c(dataset$TRcol,dataset$DAcol)])
		duplRows<-which(duplicated(duplCond) == TRUE)
		}
#now extract the names of the cues, and the inhibitors/stimuli
	namesCues<-colnames(dataset$dataMatrix)[dataset$TRcol]
	
	if(subfield == TRUE){
		namesCues<-sub(pattern="(TR:)",x=namesCues, replacement="",perl=TRUE)
		tagInhib<-grep(pattern="i:Inhibitor", x=namesCues)
		namesCues<-sub(pattern="(:\\w*$)",x=namesCues, replacement="",perl=TRUE)
		namesCues[tagInhib]<-sub(
			pattern="(i$)",
			x=namesCues[tagInhib],
			replacement="",
			perl=TRUE)
		namesStimuli<-namesCues[-tagInhib]
		namesInhibitors<-namesCues[tagInhib]
		}
		
	if(subfield == FALSE){
		namesCues<-sub(pattern="(TR:)",x=namesCues, replacement="",perl=TRUE)
		tagInhib<-grep(pattern="(i$)", x=namesCues, perl=TRUE,ignore.case=FALSE)
		namesCues[tagInhib]<-sub(
			pattern="(i$)",
			x=namesCues[tagInhib],
			replacement="",
			perl=TRUE)
		namesStimuli<-namesCues[-tagInhib]
		namesInhibitors<-namesCues[tagInhib]
		}
		
	if(sum("NOCYTO" %in% namesCues) != 0){
		namesCues<-namesCues[-grep(pattern="NOCYTO", namesCues)]
		namesStimuli<-namesStimuli[-grep(pattern="NOCYTO", namesStimuli)]
		}
		
	if(sum("NOINHIB" %in% namesCues) != 0){
		namesCues<-namesCues[-grep(pattern="NOINHIB", namesCues)]
		namesStimuli<-namesStimuli[-grep(pattern="NOINHIB", namesStimuli)]
		}	
		
#now extract the names of the signals
	namesSignals<-colnames(dataset$dataMatrix)[dataset$DAcol]
	namesSignals<-sub(
		pattern="(DA:p-)",
		x=namesSignals, 
		replacement="",
		perl=TRUE)	
	namesSignals<-sub(
		pattern="(DA:)",
		x=namesSignals, 
		replacement="",
		perl=TRUE)
		
#now extract the time signals
	times<-as.factor(as.vector(as.character(as.matrix(dataset$dataMatrix[,dataset$DAcol]))))
	timeSignals<-sort(as.integer(levels(times)))
	
#Build the valueCues matrix (i.e. a matrix with nrows=nrows in dataMatrix and ncol=number of cues,
#filled with 0/1 if the particular cue is present or not)

#1.I create a matrix that is a subset of the data, and only contains the TR columns 
#(the cellLine TR column was removed previously)

#2.I remove the columns with NOCYTO or NOINHIB (if they exist), they don't bring any info

	if(length(grep(pattern="NOCYTO",colnames(dataset$dataMatrix)[dataset$TRcol])) != 0){
	
		nocyto<-grep(pattern="NOCYTO",colnames(dataset$dataMatrix)[dataset$TRcol])
		TRcol<-dataset$TRcol[-nocyto]
		cues<-dataset$dataMatrix[,TRcol]
		
		}else{
		
			cues<-dataset$dataMatrix[,dataset$TRcol]
			}
			
	if(length(grep(pattern="NOINHIB",colnames(cues))) != 0){
		noinhib<-grep(pattern="NOINHIB",colnames(cues))
		cues<-cues[,-noinhib]
		}	
		
#3. The cues sub-data frame now contains 1 if the cue is present and 0/NA otherwise,
#so I just need to transform the data frame into a numerical matrix 
#and replace the NA in there by zeros
	cues<-as.matrix(cues,nrow=dim(cues)[1],ncol=dim(cues)[2],byrow=TRUE)
	cues[is.na(cues)]<-0
	
#Build the valueSignals matrices. I am going to build one big matrix 
#that includes all the time points, and then I will split it into one matrix for each time point
#And then I will arrange the valueCues matrix accordingly
	valueSignals<-as.matrix(dataset$dataMatrix[,dataset$DVcol])
	
#This bit will create an index that contains all rows with timept1, 2, 3,...

#1.First I create a matrix that holds the time information for each row
	times<-as.matrix(dataset$dataMatrix[,dataset$DAcol])
	
#2. Now I check that all the columns are tha same, i.e. that each row 
#will contain data on the same time point	

	check<-rep(FALSE,(length(dataset$DAcol)-1))
	
	for(i in 1:length(check)){
		check[i]<-all.equal(times[,i],times[,(i+1)])
		}
		
	if(sum(check) != length(check))	{
		warning("Each row of your data file should contain measurements at the same time point. 
			The times for the first DA column will be considered as the times for all measurements")
		}
		
#3.Now I will only use the first column of times

#First, I create a vector timeRows that contains the indexes of the rows that contain data 
#about each time point (in increasing order of time), and the vector whereTimes that contain`
#the info about how many rows I have for each time (which will allow me to extract the right
#entries from timesRows)

	times<-times[,1]
	ntimes<-length(timeSignals)
	whereTimes<-rep(0,ntimes)
	timesRows<-0
	
	for(i in 1:ntimes){
		timesRows<-c(timesRows,which(times == timeSignals[i]))
		whereTimes[i]<-length(which(times == timeSignals[i]))
		}		
		
	timesRows<-timesRows[2:length(timesRows)]	
	
#Check that we have data across all conditions for all time points except zero
	if(length(unique(whereTimes[2:length(whereTimes)])) != 1){
		warning("This program expects data across all conditions at all time points (except t=0) ")
		}
		
	print("Please be aware that if you only have some conditions at time zero (e.g.only inhibitor/no inhibitor), the measurements for these conditions will be copied across matching conditions at t=0")		

#Do the t=0 matrix, and produce a new cues matrix, that does not contain duplicates 
#(1 row per condition and different matrices will be build for the different times)
	valueSignals<-list(t0=matrix(data=0,nrow=whereTimes[2],ncol=length(dataset$DVcol)))
	
#This vector tells me which columns of the cues matrix I should pay attention to when 
#copying data across for time=0	
	zerosCond<-apply(cues[timesRows[1:whereTimes[1]],],1,function(x) which(x == 1))
	zerosCond<-unique(unlist(zerosCond))
	count=1
	newcues<-matrix(data=0,nrow=whereTimes[2],ncol=dim(cues)[2])
	
		for(i in timesRows[1]:timesRows[whereTimes[1]]){
			present<-zerosCond[which(cues[timesRows[i],zerosCond] == 1)]
			
			if(length(present) == 0){
			
				for(n in timesRows[(whereTimes[1]+1):(whereTimes[1]+whereTimes[2])]){
				
						if(sum(cues[n,zerosCond]) == 0){
							valueSignals$t0[count,]<-as.numeric(dataset$dataMatrix[i,dataset$DVcol])
							newcues[count,]<-cues[n,]
							count=count+1
							}
							
						}
						
				}else{
				
					for(n in timesRows[(whereTimes[1]+1):(whereTimes[1]+whereTimes[2])]){
					
						if(length(zerosCond[which(cues[n,zerosCond] == 1)]) == length(present)){
						
							if(all(zerosCond[which(cues[n,zerosCond] == 1)] == present) && 
								length(which(cues[n,zerosCond] == 1)) != 0){
								valueSignals$t0[count,]<-as.numeric(dataset$dataMatrix[i,dataset$DVcol])
								newcues[count,]<-cues[n,]
								count=count+1
								}
								
							}	
							
						}
					}	
			}
			
#Now build the matrices for the other time points
	for(i in 2:length(timeSignals)){
	
		valuesTi<-matrix(data=0,nrow=whereTimes[2],ncol=length(dataset$DVcol))
		
		for(n in 1:dim(newcues)[1]){
			rowsMatchCues<-apply(cues,1,function(x) all(x == newcues[n,]))
			rowsmatchTime<-times == timeSignals[i]
			rowsMatch<-which((rowsMatchCues + rowsmatchTime) == 2)
			valuesTi[n,]<-as.numeric(dataset$dataMatrix[rowsMatch,dataset$DVcol])
			}
			
		valueSignals[[i]]<-valuesTi
		
		}
		
#Build the valueInhibitors and valueStimuli  matrices, which are a subset of the cues one

	if(subfield == TRUE){
	
		valueInhibitors<-newcues[,grep(
			pattern="Inhibitor",x=colnames(cues),ignore.case=TRUE)]
		valueStimuli<-newcues[,-grep(
			pattern="Inhibitor",x=colnames(cues),ignore.case=TRUE)]
		
		}else{
		
			valueInhibitors<-newcues[,grep(
				pattern="(i$)",x=colnames(cues),ignore.case=FALSE,perl=TRUE)]
			valueStimuli<-newcues[,-grep(
				pattern="(i$)",x=colnames(cues),ignore.case=FALSE,perl=TRUE)]
			
			}
			
	if(is.null(dim(valueInhibitors))){
		valueInhibitors<-as.matrix(valueInhibitors,nrow=dim(newcues)[1])
		}
		
	if(is.null(dim(valueStimuli))){
		valueStimuli<-as.matrix(valueStimuli,nrow=dim(newcues)[1])
		}
		
	return(list(
		namesCues=namesCues,
		namesStimuli=namesStimuli,
		namesInhibitors=namesInhibitors,
		namesSignals=namesSignals,
		timeSignals=timeSignals,
		valueCues=newcues,
		valueInhibitors=valueInhibitors,
		valueStimuli=valueStimuli,
		valueSignals=valueSignals))
	
	}

