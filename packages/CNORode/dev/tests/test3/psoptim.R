psoptim <- function (par, fn, gr = NULL, ..., lower=-1, upper=1,
                     control = list()) {
  fn1 <- function(par) fn(par, ...)/p.fnscale
  mrunif <- function(n,m,lower,upper) {
    return(matrix(runif(n*m,0,1),nrow=n,ncol=m)*(upper-lower)+lower)
  }
  
  library(doSMP);
  norm <- function(x) sqrt(sum(x*x))
  npar <- length(par)
  lower <- as.double(rep(lower, ,npar))
  upper <- as.double(rep(upper, ,npar))
  con <- list(trace = 0, fnscale = 1, maxit = 1000L, maxf = Inf,
              abstol = -Inf, reltol = 0, REPORT = 10,
              s = NA, k = 3, p = NA, w = 1/(2*log(2)),
              c.p = .5+log(2), c.g = .5+log(2), d = NA,
              v.max = NA, rand.order = TRUE, max.restart=Inf,
              maxit.stagnate = Inf,
              vectorize=FALSE, hybrid = FALSE, hybrid.control = NULL)
  nmsC <- names(con)
  con[(namc <- names(control))] <- control
  if (length(noNms <- namc[!namc %in% nmsC])) 
    warning("unknown names in control: ", paste(noNms, collapse = ", "))
  ## Argument error checks
  if (any(upper==Inf | lower==-Inf))
    stop("fixed bounds must be provided")

  p.trace <- con[["trace"]]>0L # provide output on progress?
  p.fnscale <- con[["fnscale"]] # provide output on progress?
  p.maxit <- con[["maxit"]] # maximal number of iterations
  p.maxf <- con[["maxf"]] # maximal number of function evaluations
  p.abstol <- con[["abstol"]] # absolute tolerance for convergence
  p.reltol <- con[["reltol"]] # relative minimal tolerance for restarting
  p.report <- as.integer(con[["REPORT"]]) # output every REPORT iterations
  p.s <- ifelse(is.na(con[["s"]]),floor(10+2*sqrt(npar)),con[["s"]]) # swarm size
  p.p <- ifelse(is.na(con[["p"]]),1-(1-1/p.s)^con[["k"]],con[["p"]]) # average % of informants
  p.w0 <- con[["w"]] # exploitation constant
  if (length(p.w0)>1) {
    p.w1 <- p.w0[2]
    p.w0 <- p.w0[1]
  } else {
    p.w1 <- p.w0
  }
  p.c.p <- con[["c.p"]] # local exploration constant
  p.c.g <- con[["c.g"]] # global exploration constant
  p.d <- ifelse(is.na(con[["d"]]),norm(upper-lower),con[["d"]]) # domain diameter
  p.vmax <- con[["v.max"]]*p.d # maximal velocity
  p.randorder <- as.logical(con[["rand.order"]]) # process particles in random order?
  p.maxrestart <- con[["max.restart"]] # maximal number of restarts
  p.maxstagnate <- con[["maxit.stagnate"]] # maximal number of iterations without improvement
  p.vectorize <- as.logical(con[["vectorize"]]) # vectorize?
  p.hybrid <- as.logical(con[["hybrid"]]) # use local BFGS search
  p.hcontrol <- con[["hybrid.control"]] # control parameters for hybrid optim
  if ("fnscale" %in% names(p.hcontrol))
    p.hcontrol["fnscale"] <- p.hcontrol["fnscale"]*p.fnscale
  else
    p.hcontrol["fnscale"] <- p.fnscale
  
  if (p.trace) {
    message("S=",p.s,", K=",con[["k"]],", p=",signif(p.p,4),", w0=",
            signif(p.w0,4),", w1=",
            signif(p.w1,4),", c.p=",signif(p.c.p,4),
            ", c.g=",signif(p.c.g,4))
    message("v.max=",signif(con[["v.max"]],4),
            ", d=",signif(p.d,4),", vectorize=",p.vectorize,
            ", hybrid=",p.hybrid)
  }
  ## Initialization
  if (p.reltol!=0) p.reltol <- p.reltol*p.d
  if (p.vectorize) {
    lowerM <- matrix(lower,nrow=npar,ncol=p.s)
    upperM <- matrix(upper,nrow=npar,ncol=p.s)
  }
  X <- mrunif(npar,p.s,lower,upper)
  if (!any(is.na(par)) && all(par>=lower) && all(par<=upper)) X[,1] <- par
  V <- (mrunif(npar,p.s,lower,upper)-X)/2
  if (!is.na(p.vmax)) { # scale to maximal velocity
    temp <- apply(V,2,norm)
    temp <- pmin.int(temp,p.vmax)/temp
    V <- V%*%diag(temp)
  }
  f.x <- apply(X,2,fn1) # first evaluations
  stats.feval <- p.s
  P <- X
  f.p <- f.x
  P.improved <- rep(FALSE,p.s)
  i.best <- which.min(f.p)
  error <- f.p[i.best]
  init.links <- TRUE
  if (p.trace && p.report==1)
    message("It 1: fitness=",signif(error,4))
  ## Iterations
  stats.iter <- 1
  stats.restart <- 0
  stats.stagnate <- 0
  while (stats.iter<p.maxit && stats.feval<p.maxf && error>p.abstol &&
         stats.restart<p.maxrestart && stats.stagnate<p.maxstagnate) {
    stats.iter <- stats.iter+1
    if (p.p!=1 && init.links) {
      links <- matrix(runif(p.s*p.s,0,1)<=p.p,p.s,p.s)
      diag(links) <- TRUE
    }
    ## The swarm moves
    if (!p.vectorize) {
      if (p.randorder) {
        index <- sample(p.s)
      } else {
        index <- 1:p.s
      }
	  
	  temp_res=list();
	  w <- startWorkers(workerCount = 4)
	  registerDoSMP(w)
	  ##################################################################################
      for(i in index)#%dopar%
	  {
        	temp_res[[i]]=compute_particle(p.w0,p.w1,p.maxit,p.maxf,p.c.p,p.c.g,p.vmax,p.p,p.hybrid,f,f.p,f.x,i,V,X,P,i.best,links,init.links,stats.iter,stats.feval,npar,lower,upper,fn1);
        	if (stats.feval>=p.maxf) break
      }
	  for (i in index) 
	  {
		  f.x[i]=temp_res[[i]]$f.x[i];
		  f.p[i]=temp_res[[i]]$f.p[i]
		  f.x[i]=temp_res[[i]]$f.x[i];
		  P[,i]=temp_res[[i]]$P[,i];
		  X[,i]=temp_res[[i]]$X[,i];
		  V[,i]=temp_res[[i]]$V[,i];
		  stats.feval=stats.feval+temp_res[[i]]$nevals; 
	  }
	  for (i in index) 
	  {
	 	 if (f.x[i]<f.p[i]) { # improvement
		  P[,i] <- X[,i]
		  f.p[i] <- f.x[i]
		  if (f.p[i]<f.p[i.best]) 
		  {
			  i.best <- i
		  }
	  	}
	  }
	  
	  
	  ##################################################################################
    }
    if (p.reltol!=0) {
      d <- X-P[,i.best]
      d <- sqrt(max(colSums(d*d)))
      if (d<p.reltol) {
        X <- mrunif(npar,p.s,lower,upper)
        V <- (mrunif(npar,p.s,lower,upper)-X)/2
        if (!is.na(p.vmax)) {
          temp <- apply(V,2,norm)
          temp <- pmin.int(temp,p.vmax)/temp
          V <- V%*%diag(temp)
        }
        stats.restart <- stats.restart+1
        if (p.trace) message("It ",stats.iter,": restarting")
      }
    }
    init.links <- f.p[i.best]==error # if no overall improvement
    stats.stagnate <- ifelse(init.links,stats.stagnate+1,0)
    error <- f.p[i.best]
    if (p.trace && stats.iter%%p.report==0) {
      if (p.reltol!=0) 
        message("It ",stats.iter,": fitness=",signif(error,4),
                ", swarm diam.=",signif(d,4))
      else
        message("It ",stats.iter,": fitness=",signif(error,4))
    }
  }
  if (error<=p.abstol) {
    msg <- "Converged"
    msgcode <- 0
  } else if (stats.feval>=p.maxf) {
    msg <- "Maximal number of function evaluations reached"
    msgcode <- 1
  } else if (stats.iter>=p.maxit) {
    msg <- "Maximal number of iterations reached"
    msgcode <- 2
  } else if (stats.restart>=p.maxrestart) {
    msg <- "Maximal number of restarts reached"
    msgcode <- 3
  } else {
    msg <- "Maximal number of iterations without improvement reached"
    msgcode <- 4
  }
  if (p.trace) message(msg)
  o <- list(par=P[,i.best],value=f.p[i.best],
            counts=c("function"=stats.feval,"iteration"=stats.iter,
              "restarts"=stats.restart),
            convergence=msgcode,message=msg)
  return(o)
}

setGeneric("psoptim")
setMethod(f="psoptim",
          signature=c("test.problem","missing","missing","missing","missing","ANY"),
          definition=function(par, fn, gr, ..., lower, upper, control) {
            r <- NULL
            if (missing(control)) control <- NULL
            control[["maxf"]] <- par@maxf
            if (!("maxit" %in% names(control))) control[["maxit"]] <- Inf
            control[["abstol"]] <- par@objective
            x0 <- rep(NA,par@n)
            t <- proc.time()
            for (i in 1:par@ntest) {
              r <- c(r,list(psoptim(x0,par@f,par@grad,lower=par@lower,
                                    upper=par@upper,control=control,...)))
            }
            t <- as.vector(proc.time()-t)
            return(new(Class="test.result",
                       problem=par,
                       result=r,
                       time=t))
          })
  
  compute_particle<-function(p.w0,p.w1,p.maxit,p.maxf,p.c.p,p.c.g,p.vmax,p.p,p.hybrid,f,f.p,f.x,i,V,X,P,i.best,links,init.links,stats.iter,stats.feval,npar,lower,upper,fn1)
  {
	  nevals=0;
	  if (p.p==1){
		  j <- i.best
	  }
	  else{
		  j <- which(links[,i])[which.min(f.p[links[,i]])]; # best informant
	  }
	  
	  temp <- (p.w0+(p.w1-p.w0)*max(stats.iter/p.maxit,stats.feval/p.maxf))
	  V[,i] <- temp*V[,i] # exploration tendency
	  V[,i] <- V[,i]+runif(npar,0,p.c.p)*(P[,i]-X[,i]) # exploitation
	  if (i!=j) V[,i] <- V[,i]+runif(npar,0,p.c.g)*(P[,j]-X[,i])
	  if (!is.na(p.vmax)) {
		  temp <- norm(V[,i])
		  if (temp>p.vmax) V[,i] <- (p.vmax/temp)*V[,i]
	  }
	  X[,i] <- X[,i]+V[,i]
	  ## Check bounds
	  temp <- X[,i]<lower
	  if (any(temp)) {
		  X[temp,i] <- lower[temp]
		  V[temp,i] <- 0
	  }
	  temp <- X[,i]>upper
	  if (any(temp)) {
		  X[temp,i] <- upper[temp]
		  V[temp,i] <- 0
	  }
	  ## Evaluate function
	  if (p.hybrid) {
		  temp <- optim(X[,i],fn,gr,...,method="L-BFGS-B",lower=lower,
				  upper=upper,control=p.hcontrol)
		  V[,i] <- V[,i]+temp$par-X[,i] # disregards any v.max imposed
		  X[,i] <- temp$par
		  f.x[i] <- temp$value
		  nevals <- nevals+as.integer(temp$counts[1])
	  } else {
		  f.x[i] <- fn1(X[,i])
		 nevals <- nevals+1
	  }
	 
	  
	  res=list();
	  res$V=V;
	  res$X=X;
	  res$P=P;
	  res$f.x=f.x;
	  res$f.p=f.p;
	  res$nevals=nevals;
	  return(res);
  }

